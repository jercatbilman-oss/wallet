<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîê JERCAT Wallet + Telegram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e2e8f0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: linear-gradient(to bottom right, #1e293b, #0f172a);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 1px solid #334155;
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-size: 32px;
            font-weight: 900;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 14px;
            font-weight: 600;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(to bottom right, #1e293b, #0f172a);
            border-radius: 12px;
            border: 1px solid #334155;
        }

        .section h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #f59e0b;
            font-weight: 700;
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 158, 11, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.danger {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
        }

        button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        button.secondary {
            background: #334155;
            color: #e2e8f0;
        }

        input, select {
            width: 100%;
            padding: 12px;
            background: #0f172a;
            border: 2px solid #334155;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
            color: #e2e8f0;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #f59e0b;
        }

        .warning {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 2px solid #f59e0b;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #78350f;
            font-weight: 600;
        }

        .info-box {
            background: #0f172a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            word-break: break-all;
            font-size: 14px;
            border: 2px solid #334155;
        }

        .info-box label {
            font-weight: 700;
            color: #f59e0b;
            display: block;
            margin-bottom: 8px;
        }

        .hidden { display: none; }

        .balance {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin: 20px 0;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: #0f172a;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #334155;
        }

        .stat-label {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 900;
            color: #f59e0b;
        }

        .telegram-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #0088cc 0%, #0077b5 100%);
            color: white;
            margin-left: 10px;
        }

        .auto-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            margin-left: 10px;
        }

        .safety-indicator {
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            font-weight: 600;
            border: 2px solid;
        }

        .safety-safe {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-color: #10b981;
            color: #064e3b;
        }

        .safety-warning {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #f59e0b;
            color: #78350f;
        }

        .safety-danger {
            background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%);
            border-color: #dc2626;
            color: #7f1d1d;
        }

        .rule-item {
            background: #0f172a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rule-active {
            border-color: #10b981;
        }

        .rule-inactive {
            border-color: #64748b;
            opacity: 0.6;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #334155;
            border-radius: 13px;
            cursor: pointer;
            transition: 0.3s;
        }

        .toggle-switch.active {
            background: #10b981;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: 0.3s;
        }

        .toggle-switch.active::after {
            left: 27px;
        }

        .log-entry {
            background: #0f172a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid #f59e0b;
            font-size: 13px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 700;
            margin-left: 10px;
        }

        .status-active {
            background: #d1fae5;
            color: #064e3b;
        }

        .whitelist-item {
            background: #0f172a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid #334155;
        }

        .whitelist-item button {
            width: auto;
            padding: 6px 12px;
            font-size: 12px;
            margin: 0;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }

        .telegram-setup {
            background: linear-gradient(135deg, #0088cc20 0%, #0077b520 100%);
            border: 2px solid #0088cc;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        .error { background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%); border: 2px solid #dc2626; padding: 15px; border-radius: 8px; margin-top: 15px; color: #7f1d1d; font-weight: 600; }
        .success-msg { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); border: 2px solid #10b981; padding: 15px; border-radius: 8px; margin-top: 15px; color: #064e3b; font-weight: 600; }
    </style>
</head>
<body>
    <div class="container animate-slide-in">
        <h1>ü§ñ JERCAT Wallet + Telegram</h1>
        <p class="subtitle">Validation Telegram avec Auto-Approval Intelligent</p>

        <div class="warning">
            <strong>ü§ñ S√âCURIT√â INTELLIGENTE</strong><br>
            ‚Ä¢ Transactions s√ªres = Validation automatique<br>
            ‚Ä¢ Transactions risqu√©es = Validation Telegram requise<br>
            ‚Ä¢ Vous restez toujours en contr√¥le !
        </div>

        <!-- √âcran de connexion -->
        <div id="loginScreen">
            <div class="section">
                <h2>üîì Connexion</h2>
                <input type="password" id="loginPassword" placeholder="Mot de passe">
                <button onclick="login()">D√©verrouiller</button>
                <button onclick="showCreateScreen()" class="secondary">Cr√©er un wallet</button>
            </div>
        </div>

        <!-- √âcran de cr√©ation -->
        <div id="createScreen" class="hidden">
            <div class="section">
                <h2>‚ú® Cr√©er un wallet s√©curis√©</h2>
                <input type="password" id="newPassword" placeholder="Mot de passe (min 8 caract√®res)">
                <input type="password" id="confirmPassword" placeholder="Confirmer">
                <input type="text" id="telegramChatId" placeholder="Telegram Chat ID (optionnel pour l'instant)">
                <input type="text" id="importPhrase" placeholder="(Optionnel) Phrase de r√©cup√©ration">
                <button onclick="createSecureWallet()">Cr√©er le wallet</button>
                <button onclick="showLoginScreen()" class="secondary">Retour</button>
                <div id="createMessage"></div>
                
                <div id="newWalletInfo" class="hidden">
                    <div class="info-box">
                        <label>‚ö†Ô∏è SAUVEGARDEZ CETTE PHRASE :</label>
                        <div id="displayMnemonic" style="font-weight: bold; color: #f59e0b;"></div>
                    </div>
                    <button onclick="confirmAndContinue()" class="success">‚úÖ J'ai sauvegard√©</button>
                </div>
            </div>
        </div>

        <!-- √âcran principal -->
        <div id="mainScreen" class="hidden">
            <div class="section">
                <h2>
                    üìä Dashboard
                    <span class="status-badge status-active">‚úÖ Actif</span>
                    <span class="telegram-badge">üì± Telegram</span>
                    <span class="auto-badge">ü§ñ Auto</span>
                </h2>
                <div class="info-box">
                    <label>Adresse :</label>
                    <div id="walletAddress" style="color: #94a3b8; font-family: monospace;"></div>
                </div>
                <div class="balance" id="balance">0.0000 BNB</div>
                <button onclick="refreshBalance()">üîÑ Actualiser</button>
            </div>

            <!-- Liste des tokens -->
            <div class="section">
                <h2>ü™ô Mes Tokens</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;" id="tokenBalances">
                    <div style="text-align: center; color: #64748b; padding: 20px;">
                        Chargement des tokens...
                    </div>
                </div>

                <hr style="border: 1px solid #334155; margin: 20px 0;">

                <h3 style="color: #f59e0b; font-size: 16px; margin-bottom: 15px;">‚ûï Ajouter un token</h3>
                
                <div style="background: #0f172a; padding: 15px; border-radius: 8px; border: 2px solid #334155; margin-bottom: 15px;">
                    <label style="color: #94a3b8; font-size: 13px; font-weight: 600; display: block; margin-bottom: 8px;">
                        Adresse du contrat token :
                    </label>
                    <input type="text" id="tokenAddressInput" placeholder="0x... (ex: 0x55d398326f99059fF775485246999027B3197955 pour USDT)" 
                           style="font-family: monospace; font-size: 13px;">
                    
                    <button onclick="addTokenByAddress()" style="margin-top: 10px;">
                        üîç Rechercher et ajouter ce token
                    </button>

                    <div id="tokenSearchResult" style="margin-top: 15px;"></div>
                </div>

                <div class="info-box" style="background: #10b98120; border-color: #10b981;">
                    <label style="color: #10b981;">üí° Tokens populaires sur BSC :</label>
                    <div style="color: #e2e8f0; font-size: 13px; line-height: 1.8; margin-top: 8px;">
                        <strong>USDT:</strong> <code style="background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 11px;">0x55d398326f99059fF775485246999027B3197955</code><br>
                        <strong>USDC:</strong> <code style="background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 11px;">0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d</code><br>
                        <strong>BUSD:</strong> <code style="background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 11px;">0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56</code><br>
                        <strong>CAKE:</strong> <code style="background: #0f172a; padding: 2px 6px; border-radius: 4px; font-size: 11px;">0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82</code>
                    </div>
                </div>

                <button onclick="refreshAllTokens()" class="secondary" style="margin-top: 15px;">
                    üîÑ Rafra√Æchir tous les tokens
                </button>
            </div>

            <!-- Configuration Telegram -->
            <div class="section">
                <h2>ü§ñ Configuration Telegram Bot</h2>
                
                <div class="telegram-setup">
                    <h3 style="color: #0088cc; margin-bottom: 15px; font-size: 16px;">ü§ñ √âtape 1 : Cr√©er votre bot Telegram</h3>
                    <ol style="color: #e2e8f0; line-height: 2; margin-left: 20px; font-size: 14px;">
                        <li>Ouvrez Telegram</li>
                        <li>Recherchez <strong style="color: #f59e0b;">@BotFather</strong></li>
                        <li>Envoyez <strong style="color: #f59e0b;">/newbot</strong></li>
                        <li>Suivez les instructions pour cr√©er votre bot</li>
                        <li>Copiez le <strong style="color: #f59e0b;">Token</strong> que BotFather vous donne</li>
                        <li>Collez-le ci-dessous ‚¨áÔ∏è</li>
                    </ol>
                </div>

                <div class="info-box" style="margin-top: 15px; background: #0088cc20; border-color: #0088cc;">
                    <label style="color: #0088cc;">üîë Token de votre Bot Telegram :</label>
                    <div style="color: #e2e8f0; font-size: 12px; margin-bottom: 10px;">
                        Format : 1234567890:ABCdefGHIjklMNOpqrsTUVwxyz
                    </div>
                    <input type="text" id="botTokenInput" placeholder="Collez votre Bot Token ici..." 
                           style="font-family: monospace; font-size: 13px;" 
                           value="">
                </div>
                
                <button onclick="saveBotToken()" style="margin-top: 10px;">üíæ Enregistrer le Bot Token</button>

                <div id="botTokenStatus" class="info-box" style="margin-top: 15px;">
                    <label>ü§ñ Statut du Bot :</label>
                    <div id="botTokenStatusText" style="color: #64748b;">Non configur√©</div>
                </div>

                <hr style="border: 1px solid #334155; margin: 30px 0;">

                <div class="telegram-setup">
                    <h3 style="color: #0088cc; margin-bottom: 15px; font-size: 16px;">üì± √âtape 2 : Obtenir votre Chat ID</h3>
                    <ol style="color: #e2e8f0; line-height: 2; margin-left: 20px; font-size: 14px;">
                        <li>Toujours dans Telegram</li>
                        <li>Recherchez <strong style="color: #f59e0b;">@userinfobot</strong></li>
                        <li>Envoyez <strong style="color: #f59e0b;">/start</strong></li>
                        <li>Copiez votre <strong style="color: #f59e0b;">Chat ID</strong> (les chiffres)</li>
                        <li>Collez-le ci-dessous ‚¨áÔ∏è</li>
                    </ol>
                </div>

                <input type="text" id="newTelegramId" placeholder="Votre Telegram Chat ID (ex: 123456789)" value="">
                <button onclick="updateTelegramId()">üíæ Enregistrer le Chat ID</button>
                
                <div id="telegramStatus" class="info-box" style="margin-top: 15px;">
                    <label>üì± Statut Chat ID :</label>
                    <div id="telegramStatusText" style="color: #64748b;">Non configur√©</div>
                </div>

                <hr style="border: 1px solid #334155; margin: 20px 0;">

                <h3 style="color: #10b981; margin-bottom: 15px; font-size: 16px;">üß™ Tests & Diagnostic</h3>

                <button onclick="testTelegram()" class="secondary" style="margin-bottom: 10px;">üß™ Test 1: Tester la connexion Telegram</button>

                <button onclick="checkRecentTransactions()" class="secondary" style="margin-bottom: 10px;">üîç Test 2: V√©rifier mes transactions r√©centes</button>

                <button onclick="sendTestNotification()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); margin-bottom: 10px;">üì± Test 3: Envoyer une notification de test</button>

                <div id="diagnosticResults" style="margin-top: 15px;"></div>
                
                <div class="warning" style="margin-top: 20px;">
                    <strong>‚ö†Ô∏è S√âCURIT√â</strong><br>
                    ‚Ä¢ Gardez votre Bot Token SECRET<br>
                    ‚Ä¢ Ne le partagez JAMAIS avec personne<br>
                    ‚Ä¢ Il est stock√© localement dans votre navigateur<br>
                    ‚Ä¢ Supprimez-le si vous utilisez un ordinateur public
                </div>

                <button onclick="clearTelegramConfig()" class="danger" style="margin-top: 10px;">üóëÔ∏è Supprimer toute la config Telegram</button>
            </div>

            <!-- Applications de confiance -->
            <div class="section">
                <h2>üîê Applications de confiance JERCAT</h2>
                <p style="color: #94a3b8; font-size: 13px; margin-bottom: 15px;">
                    Les transactions provenant de ces applications sont automatiquement valid√©es
                </p>

                <div id="trustedAppsDisplay"></div>

                <div style="margin-top: 15px;">
                    <input type="text" id="newTrustedApp" placeholder="Nom de l'application (ex: jercat-bot)">
                    <button onclick="addTrustedApp()">‚ûï Ajouter une app de confiance</button>
                </div>

                <div class="info-box" style="margin-top: 15px; background: #0088cc20; border-color: #0088cc;">
                    <label style="color: #0088cc;">üí° Apps pr√©-configur√©es :</label>
                    <div style="color: #e2e8f0; font-size: 13px; line-height: 1.8;">
                        ‚Ä¢ <strong>jercat-wallet</strong> - Votre wallet JERCAT<br>
                        ‚Ä¢ <strong>jercat-dex</strong> - Votre DEX JERCAT<br>
                        ‚Ä¢ <strong>jercat-bot</strong> - Votre bot de trading<br>
                        ‚Ä¢ <strong>wallet-one-ochre.vercel.app</strong> - Wallet d√©ploy√©
                    </div>
                </div>
            </div>

            <!-- Protection contre les airdrops scam -->
            <div class="section">
                <h2>üõ°Ô∏è Protection Anti-Scam (Airdrops)</h2>
                <p style="color: #94a3b8; font-size: 13px; margin-bottom: 15px;">
                    Surveillance des tokens entrants non autoris√©s
                </p>

                <div class="rule-item rule-active" id="rule-blockScam">
                    <div class="toggle-switch active" onclick="toggleProtection('blockSuspiciousTokens')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üö´ Bloquer les tokens suspects</div>
                        <div style="color: #64748b; font-size: 12px;">Emp√™che toute interaction avec les tokens non v√©rifi√©s</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-telegramNewToken">
                    <div class="toggle-switch active" onclick="toggleProtection('requireTelegramForNewTokens')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üì± Validation Telegram pour nouveaux tokens</div>
                        <div style="color: #64748b; font-size: 12px;">Toute transaction avec un nouveau token n√©cessite votre approbation</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-autoScan">
                    <div class="toggle-switch active" onclick="toggleProtection('autoScanIncoming')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üîç Scanner automatique</div>
                        <div style="color: #64748b; font-size: 12px;">Analyse automatique des nouveaux tokens re√ßus</div>
                    </div>
                </div>

                <button onclick="scanWalletTokens()" class="secondary" style="margin-top: 15px;">üîç Scanner mon wallet maintenant</button>

                <!-- Alertes de tokens suspects -->
                <div id="suspiciousTokenAlerts" class="hidden" style="margin-top: 20px;"></div>

                <!-- Liste des tokens connus -->
                <div style="margin-top: 20px;">
                    <h3 style="color: #10b981; font-size: 16px; margin-bottom: 10px;">‚úÖ Tokens de confiance</h3>
                    <div id="knownTokensList" style="max-height: 200px; overflow-y: auto;"></div>
                    
                    <div style="margin-top: 15px;">
                        <input type="text" id="newTrustedToken" placeholder="Adresse du token (0x...)">
                        <input type="text" id="newTokenSymbol" placeholder="Symbole (ex: USDT)">
                        <button onclick="addTrustedToken()">‚ûï Ajouter un token de confiance</button>
                    </div>
                </div>

                <!-- Tokens suspects d√©tect√©s -->
                <div id="suspiciousTokensSection" class="hidden" style="margin-top: 20px;">
                    <h3 style="color: #dc2626; font-size: 16px; margin-bottom: 10px;">‚ö†Ô∏è Tokens suspects d√©tect√©s</h3>
                    <div id="suspiciousTokensList"></div>
                </div>
            </div>

            <!-- R√®gles d'Auto-Validation -->
            <div class="section">
                <h2>ü§ñ R√®gles d'Auto-Validation</h2>
                <p style="color: #94a3b8; font-size: 13px; margin-bottom: 15px;">
                    Activez les r√®gles pour valider automatiquement les transactions s√ªres
                </p>

                <div class="rule-item rule-active" id="rule-whitelist">
                    <div class="toggle-switch active" onclick="toggleRule('whitelist')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">‚úÖ Adresses en liste blanche</div>
                        <div style="color: #64748b; font-size: 12px;">Auto-valide si destinataire dans la whitelist</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-amount">
                    <div class="toggle-switch active" onclick="toggleRule('amount')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üí∞ Montants faibles</div>
                        <div style="color: #64748b; font-size: 12px;">Auto-valide si montant < <input type="number" id="autoAmountLimit" value="0.1" step="0.01" style="width: 80px; display: inline-block; padding: 4px;"> BNB</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-frequency">
                    <div class="toggle-switch active" onclick="toggleRule('frequency')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">‚è±Ô∏è Fr√©quence normale</div>
                        <div style="color: #64748b; font-size: 12px;">Auto-valide si pas plus de 3 tx en 1 heure</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-time">
                    <div class="toggle-switch active" onclick="toggleRule('time')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üåô Heures normales</div>
                        <div style="color: #64748b; font-size: 12px;">Auto-valide entre 8h et 23h</div>
                    </div>
                </div>

                <div class="rule-item rule-active" id="rule-trustedApps">
                    <div class="toggle-switch active" onclick="toggleRule('trustedApps')"></div>
                    <div style="flex: 1;">
                        <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">üîê Applications de confiance</div>
                        <div style="color: #64748b; font-size: 12px;">Auto-valide si transaction vient de JERCAT Wallet, DEX ou Bot</div>
                    </div>
                </div>
            </div>

            <!-- Statistiques -->
            <div class="section">
                <h2>üìà Statistiques & Monitoring</h2>
                
                <div class="info-box" style="margin-bottom: 15px;">
                    <label>üîç Surveillance des transactions :</label>
                    <div id="monitoringStatus" style="color: #10b981; font-weight: 700; margin-top: 8px;">
                        ‚è≥ Initialisation...
                    </div>
                </div>

                <button onclick="forceCheckTransactions()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); margin-bottom: 15px;">
                    üîÑ V√©rifier les nouvelles transactions MAINTENANT
                </button>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Max par transaction</div>
                        <div class="stat-value" id="maxPerTx">1.0 BNB</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Limite quotidienne</div>
                        <div class="stat-value" id="dailyLimit">10.0 BNB</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">D√©pens√© aujourd'hui</div>
                        <div class="stat-value" id="dailySpent" style="color: #10b981;">0.0 BNB</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Auto-valid√©es</div>
                        <div class="stat-value" id="autoApproved" style="color: #10b981;">0</div>
                    </div>
                </div>

                <div id="lastCheckInfo" class="info-box" style="margin-top: 15px;">
                    <label>Derni√®re v√©rification :</label>
                    <div id="lastCheckTime" style="color: #64748b; font-size: 12px;">Jamais</div>
                </div>
            </div>

            <!-- Configuration limites -->
            <div class="section">
                <h2>‚öôÔ∏è Configuration</h2>
                <input type="number" id="newMaxTx" placeholder="Max par transaction (BNB)" step="0.1">
                <input type="number" id="newDailyLimit" placeholder="Limite quotidienne (BNB)" step="0.1">
                <button onclick="updateLimits()">üíæ Mettre √† jour</button>
            </div>

            <!-- Liste blanche -->
            <div class="section">
                <h2>üõ°Ô∏è Liste blanche</h2>
                <div id="whitelistDisplay"></div>
                <input type="text" id="newWhitelistAddress" placeholder="0x... Adresse √† autoriser">
                <button onclick="addToWhitelist()">‚ûï Ajouter</button>
            </div>

            <!-- Trading -->
            <div class="section">
                <h2>üí± Envoyer / Trader</h2>
                <input type="text" id="recipientAddress" placeholder="Adresse destinataire">
                <input type="number" id="sendAmount" placeholder="Montant" step="0.0001">
                
                <div id="safetyCheck" class="hidden"></div>
                
                <button onclick="prepareTransaction()" id="tradeBtn" class="success">üöÄ Pr√©parer la transaction</button>
                <div id="tradeMessage"></div>
            </div>

            <!-- Logs -->
            <div class="section">
                <h2>üìã Historique</h2>
                <div id="transactionLogs"></div>
            </div>

            <!-- Contr√¥les -->
            <div class="section">
                <h2>üö® Contr√¥les</h2>
                <button onclick="logout()" class="secondary">üîí Verrouiller</button>
            </div>
        </div>
    </div>

    <script>
        const BSC_RPC = "https://bsc-dataseed.binance.org/";
        let provider = new ethers.JsonRpcProvider(BSC_RPC);
        let wallet = null;

        // Le bot token sera configur√© via l'interface, pas dans le code
        let TELEGRAM_BOT_TOKEN = localStorage.getItem('telegramBotToken') || '';

        let securityConfig = {
            maxPerTransaction: 1.0,
            dailyLimit: 10.0,
            dailySpent: 0.0,
            lastResetDate: new Date().toDateString(),
            telegramChatId: '',
            whitelist: ["0x10ED43C718714eb63d5aA57B78B54704E256024E"],
            transactionLogs: [],
            autoApprovedCount: 0,
            recentTransactions: [],
            autoRules: {
                whitelist: true,
                amount: true,
                frequency: true,
                time: true,
                trustedApps: true
            },
            autoAmountLimit: 0.1,
            trustedOrigins: [
                'jercat-wallet',
                'jercat-dex',
                'jercat-bot',
                'localhost',
                'wallet-one-ochre.vercel.app'
            ],
            // Nouvelle section pour les tokens
            knownTokens: [
                { address: '0x197CF8951d93325A9333857Ee5330daF7aC4bcCF', symbol: 'JERCAT', trusted: true },
                { address: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', symbol: 'WBNB', trusted: true },
                { address: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', symbol: 'BUSD', trusted: true },
                { address: '0x55d398326f99059fF775485246999027B3197955', symbol: 'USDT', trusted: true },
                { address: '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', symbol: 'CAKE', trusted: true }
            ],
            suspiciousTokens: [],
            incomingTokenAlerts: [],
            protectionSettings: {
                blockSuspiciousTokens: true,
                requireTelegramForNewTokens: true,
                autoScanIncoming: true
            }
        };

        function loadConfig() {
            const saved = localStorage.getItem('securityConfig');
            if (saved) {
                securityConfig = { ...securityConfig, ...JSON.parse(saved) };
                checkDailyReset();
                updateStatsDisplay();
                updateWhitelistDisplay();
                updateLogsDisplay();
                updateTelegramStatus();
                updateRulesDisplay();
            }
        }

        function saveConfig() {
            localStorage.setItem('securityConfig', JSON.stringify(securityConfig));
        }

        function checkDailyReset() {
            const today = new Date().toDateString();
            if (securityConfig.lastResetDate !== today) {
                securityConfig.dailySpent = 0;
                securityConfig.autoApprovedCount = 0;
                securityConfig.lastResetDate = today;
                saveConfig();
            }
        }

        function encryptAndSave(wallet, password) {
            const data = JSON.stringify({
                mnemonic: wallet.mnemonic.phrase,
                address: wallet.address
            });
            const encrypted = CryptoJS.AES.encrypt(data, password).toString();
            localStorage.setItem('encryptedWallet', encrypted);
        }

        function decryptWallet(password) {
            const encrypted = localStorage.getItem('encryptedWallet');
            if (!encrypted) return null;
            try {
                const decrypted = CryptoJS.AES.decrypt(encrypted, password).toString(CryptoJS.enc.Utf8);
                const data = JSON.parse(decrypted);
                return ethers.Wallet.fromPhrase(data.mnemonic);
            } catch (error) {
                return null;
            }
        }

        function createSecureWallet() {
            const password = document.getElementById('newPassword').value;
            const confirm = document.getElementById('confirmPassword').value;
            const chatId = document.getElementById('telegramChatId').value.trim();
            const importPhrase = document.getElementById('importPhrase').value.trim();
            const messageDiv = document.getElementById('createMessage');

            if (password.length < 8) {
                messageDiv.innerHTML = '<div class="error">‚ùå Mot de passe trop court.</div>';
                return;
            }

            if (password !== confirm) {
                messageDiv.innerHTML = '<div class="error">‚ùå Mots de passe diff√©rents.</div>';
                return;
            }

            try {
                wallet = importPhrase ? ethers.Wallet.fromPhrase(importPhrase) : ethers.Wallet.createRandom();
                encryptAndSave(wallet, password);
                
                if (chatId) {
                    securityConfig.telegramChatId = chatId;
                }
                saveConfig();

                document.getElementById('displayMnemonic').textContent = wallet.mnemonic.phrase;
                document.getElementById('newWalletInfo').classList.remove('hidden');
                messageDiv.innerHTML = '<div class="success-msg">‚úÖ Wallet cr√©√© !</div>';
            } catch (error) {
                messageDiv.innerHTML = '<div class="error">‚ùå ' + error.message + '</div>';
            }
        }

        function confirmAndContinue() {
            showMainScreen();
        }

        function login() {
            const password = document.getElementById('loginPassword').value;
            wallet = decryptWallet(password);

            if (wallet) {
                showMainScreen();
            } else {
                alert('‚ùå Mot de passe incorrect.');
            }
        }

        function showMainScreen() {
            wallet = wallet.connect(provider);
            const account = wallet.address;
            document.getElementById('walletAddress').textContent = account;
            
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('createScreen').classList.add('hidden');
            document.getElementById('mainScreen').classList.remove('hidden');

            loadConfig();
            refreshBalance(); // Charge aussi les tokens
            updateProtectionDisplay();
            updateBotTokenStatus();
            updateTelegramStatus();

            // Activer le scan automatique si activ√©
            if (securityConfig.protectionSettings.autoScanIncoming) {
                console.log('üîç Scanner automatique activ√©');
                // En production, √©couter les √©v√©nements Transfer du wallet
            }

            // üî• NOUVEAU: Surveiller TOUTES les transactions (m√™me externes)
            startTransactionMonitoring(account);
        }

        // ========== SURVEILLANCE DES TRANSACTIONS EN TEMPS R√âEL ==========
        
        let monitoringInterval = null;
        let lastCheckedBlock = null;

        async function startTransactionMonitoring(walletAddress) {
            console.log('üîç Surveillance des transactions activ√©e pour:', walletAddress);

            // Obtenir le dernier bloc v√©rifi√©
            const currentBlock = await provider.getBlockNumber();
            
            // Charger depuis le stockage OU scanner les 1000 derniers blocs
            const savedBlock = localStorage.getItem('lastCheckedBlock');
            if (savedBlock) {
                lastCheckedBlock = parseInt(savedBlock);
            } else {
                lastCheckedBlock = currentBlock - 1000; // Scanner les 1000 derniers blocs au d√©marrage
            }

            updateMonitoringStatus(`‚úÖ Actif - Dernier bloc: ${currentBlock}`);

            // V√©rifier imm√©diatement au d√©marrage
            await checkNewTransactions(walletAddress);

            // Puis v√©rifier toutes les 10 secondes (plus rapide!)
            monitoringInterval = setInterval(async () => {
                try {
                    await checkNewTransactions(walletAddress);
                } catch (error) {
                    console.error('Erreur monitoring:', error);
                    updateMonitoringStatus(`‚ö†Ô∏è Erreur: ${error.message}`);
                }
            }, 10000); // 10 secondes
        }

        function updateMonitoringStatus(message) {
            const statusDiv = document.getElementById('monitoringStatus');
            if (statusDiv) {
                statusDiv.textContent = message;
            }
            
            const lastCheckDiv = document.getElementById('lastCheckTime');
            if (lastCheckDiv) {
                lastCheckDiv.textContent = new Date().toLocaleString('fr-FR');
            }
        }

        async function forceCheckTransactions() {
            if (!wallet) {
                alert('‚ùå Wallet non d√©verrouill√©');
                return;
            }

            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üîç V√©rification en cours...';

            try {
                updateMonitoringStatus('üîç V√©rification forc√©e en cours...');
                
                const currentBlock = await provider.getBlockNumber();
                
                // Scanner les 2000 derniers blocs (~1.5 heures)
                const startBlock = currentBlock - 2000;
                lastCheckedBlock = startBlock;
                
                console.log(`üîç Scan forc√© des blocs ${startBlock} √† ${currentBlock}`);
                
                await checkNewTransactions(wallet.address);
                
                updateMonitoringStatus(`‚úÖ Scan termin√© - Bloc actuel: ${currentBlock}`);
                alert('‚úÖ V√©rification termin√©e ! Si des transactions ont √©t√© trouv√©es, vous avez re√ßu des notifications.');
                
            } catch (error) {
                console.error('Erreur scan forc√©:', error);
                updateMonitoringStatus(`‚ùå Erreur: ${error.message}`);
                alert('‚ùå Erreur: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîÑ V√©rifier les nouvelles transactions MAINTENANT';
            }
        }

        async function checkNewTransactions(walletAddress) {
            const currentBlock = await provider.getBlockNumber();
            
            if (!lastCheckedBlock) {
                lastCheckedBlock = currentBlock - 100;
            }

            const blocksToCheck = currentBlock - lastCheckedBlock;
            
            console.log(`üîç Scan des blocs ${lastCheckedBlock + 1} √† ${currentBlock} (${blocksToCheck} blocs)`);
            updateMonitoringStatus(`üîç Scan de ${blocksToCheck} nouveaux blocs...`);

            let foundCount = 0;

            // Scanner par batch de 100 blocs pour plus de rapidit√©
            const batchSize = 100;
            for (let batchStart = lastCheckedBlock + 1; batchStart <= currentBlock; batchStart += batchSize) {
                const batchEnd = Math.min(batchStart + batchSize - 1, currentBlock);
                
                try {
                    // Utiliser l'API BSCScan pour plus de rapidit√© (en production)
                    // Pour l'instant, on continue avec getBlock
                    
                    for (let blockNumber = batchStart; blockNumber <= batchEnd; blockNumber++) {
                        try {
                            const block = await provider.getBlock(blockNumber, true);
                            
                            if (block && block.transactions) {
                                for (let tx of block.transactions) {
                                    // V√©rifier si c'est une transaction de notre wallet
                                    if (typeof tx === 'object' && tx.from && tx.from.toLowerCase() === walletAddress.toLowerCase()) {
                                        await handleExternalTransaction(tx);
                                        foundCount++;
                                    } else if (typeof tx === 'string') {
                                        // Si c'est juste un hash, le r√©cup√©rer
                                        const fullTx = await provider.getTransaction(tx);
                                        if (fullTx && fullTx.from && fullTx.from.toLowerCase() === walletAddress.toLowerCase()) {
                                            await handleExternalTransaction(fullTx);
                                            foundCount++;
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.error(`Erreur scan bloc ${blockNumber}:`, error);
                        }
                    }
                } catch (error) {
                    console.error(`Erreur batch ${batchStart}-${batchEnd}:`, error);
                }

                // Mise √† jour de la progression
                if (blocksToCheck > 100 && batchStart % 500 === 0) {
                    const progress = Math.floor(((batchStart - lastCheckedBlock) / blocksToCheck) * 100);
                    updateMonitoringStatus(`üîç Scan en cours... ${progress}%`);
                }
            }

            lastCheckedBlock = currentBlock;
            localStorage.setItem('lastCheckedBlock', currentBlock.toString());

            if (foundCount > 0) {
                updateMonitoringStatus(`‚úÖ ${foundCount} transaction(s) d√©tect√©e(s) - Bloc: ${currentBlock}`);
                console.log(`‚úÖ ${foundCount} transaction(s) trouv√©e(s)`);
            } else {
                updateMonitoringStatus(`‚úÖ Aucune nouvelle transaction - Bloc: ${currentBlock}`);
            }
        }

        async function handleExternalTransaction(tx) {
            console.log('üí∏ Transaction externe d√©tect√©e:', tx.hash);

            // V√©rifier si on a d√©j√† trait√© cette transaction
            const txId = tx.hash;
            const processedTxs = JSON.parse(localStorage.getItem('processedExternalTxs') || '[]');
            
            if (processedTxs.includes(txId)) {
                return; // D√©j√† trait√©e
            }

            // Marquer comme trait√©e
            processedTxs.push(txId);
            if (processedTxs.length > 100) {
                processedTxs.shift(); // Garder seulement les 100 derni√®res
            }
            localStorage.setItem('processedExternalTxs', JSON.stringify(processedTxs));

            // Obtenir les d√©tails de la transaction
            const receipt = await provider.getTransactionReceipt(txId);
            
            if (!receipt) {
                return; // Transaction pas encore min√©e
            }

            const amount = parseFloat(ethers.formatEther(tx.value));
            const to = tx.to || 'Contract Creation';
            const gasUsed = receipt.gasUsed;
            const gasPrice = tx.gasPrice;
            const gasCost = parseFloat(ethers.formatEther(gasUsed * gasPrice));
            const timestamp = new Date().toLocaleString();

            // Ajouter au log
            securityConfig.transactionLogs.unshift({
                time: timestamp,
                amount: amount,
                to: to,
                hash: txId,
                status: receipt.status === 1 ? 'success' : 'failed',
                external: true,
                gasCost: gasCost
            });

            if (securityConfig.transactionLogs.length > 20) {
                securityConfig.transactionLogs = securityConfig.transactionLogs.slice(0, 20);
            }

            saveConfig();
            updateLogsDisplay();

            // Envoyer notification Telegram
            if (TELEGRAM_BOT_TOKEN && securityConfig.telegramChatId) {
                const emoji = receipt.status === 1 ? '‚úÖ' : '‚ùå';
                const statusText = receipt.status === 1 ? 'Confirm√©e' : '√âchou√©e';
                
                const message = `
${emoji} <b>Transaction ${statusText} (Externe)</b>

‚ö†Ô∏è <b>Transaction effectu√©e en dehors du Secure Wallet</b>

üí∞ Montant: <b>${amount.toFixed(4)} BNB</b>
üìç Destinataire: <code>${to}</code>
‚õΩ Frais de gas: ${gasCost.toFixed(6)} BNB
üíµ Total: <b>${(amount + gasCost).toFixed(4)} BNB</b>

üîó Hash: <code>${txId.substring(0, 20)}...</code>
‚è∞ ${timestamp}

üí° <b>Conseil:</b> Utilisez le Secure Wallet pour b√©n√©ficier de toutes les protections !
`;

                try {
                    await sendTelegramMessage(message);
                    console.log('üì± Notification Telegram envoy√©e');
                } catch (error) {
                    console.error('Erreur notification Telegram:', error);
                }
            }

            // Mettre √† jour le solde
            refreshBalance();
        }

        // Arr√™ter la surveillance lors du logout
        function stopTransactionMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                console.log('üõë Surveillance des transactions arr√™t√©e');
            }
        }

        async function refreshBalance() {
            if (!wallet) return;
            try {
                const balance = await provider.getBalance(wallet.address);
                document.getElementById('balance').textContent = parseFloat(ethers.formatEther(balance)).toFixed(4) + ' BNB';
                
                // Rafra√Æchir aussi les tokens
                await loadTokenBalances();
            } catch (error) {
                console.error(error);
            }
        }

        // ========== GESTION DES TOKENS ERC20 ==========

        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function name() view returns (string)",
            "function transfer(address to, uint256 amount) returns (bool)"
        ];

        async function loadTokenBalances() {
            if (!wallet) return;

            const tokenBalancesDiv = document.getElementById('tokenBalances');
            tokenBalancesDiv.innerHTML = '<div style="text-align: center; color: #64748b; padding: 20px;">üîÑ Chargement...</div>';

            try {
                const userAddress = wallet.address;
                const balances = [];

                // Charger les balances de tous les tokens connus
                for (const token of securityConfig.knownTokens) {
                    try {
                        const tokenContract = new ethers.Contract(token.address, ERC20_ABI, provider);
                        
                        const [balance, decimals, symbol, name] = await Promise.all([
                            tokenContract.balanceOf(userAddress),
                            tokenContract.decimals().catch(() => 18),
                            tokenContract.symbol().catch(() => token.symbol),
                            tokenContract.name().catch(() => token.symbol)
                        ]);

                        const formattedBalance = parseFloat(ethers.formatUnits(balance, decimals));

                        balances.push({
                            address: token.address,
                            symbol: symbol,
                            name: name,
                            balance: formattedBalance,
                            decimals: decimals,
                            trusted: token.trusted
                        });

                    } catch (error) {
                        console.error(`Erreur chargement ${token.symbol}:`, error);
                    }
                }

                // Afficher les balances
                if (balances.length === 0) {
                    tokenBalancesDiv.innerHTML = `
                        <div style="text-align: center; color: #64748b; padding: 20px; grid-column: 1/-1;">
                            Aucun token ajout√©.<br>
                            <span style="font-size: 12px;">Ajoutez des tokens ci-dessous ‚¨áÔ∏è</span>
                        </div>
                    `;
                } else {
                    tokenBalancesDiv.innerHTML = '';
                    
                    balances.forEach(token => {
                        const balanceColor = token.balance > 0 ? '#10b981' : '#64748b';
                        const trustBadge = token.trusted ? '<div style="position: absolute; top: 8px; right: 8px; background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 9px;">‚úì</div>' : '';
                        
                        const tokenCard = document.createElement('div');
                        tokenCard.style.cssText = 'position: relative; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border: 2px solid #334155; border-radius: 12px; padding: 15px; text-align: center;';
                        tokenCard.innerHTML = `
                            ${trustBadge}
                            <div style="font-size: 24px; margin-bottom: 8px;">ü™ô</div>
                            <div style="color: #f59e0b; font-weight: 700; font-size: 16px; margin-bottom: 4px;">${token.symbol}</div>
                            <div style="color: #64748b; font-size: 11px; margin-bottom: 8px;">${token.name}</div>
                            <div style="color: ${balanceColor}; font-weight: 900; font-size: 20px; margin-bottom: 8px;">
                                ${token.balance.toFixed(token.balance > 1 ? 2 : 6)}
                            </div>
                            <div style="font-size: 10px; color: #64748b; font-family: monospace; overflow: hidden; text-overflow: ellipsis;">
                                ${token.address.substring(0, 8)}...
                            </div>
                        `;
                        tokenBalancesDiv.appendChild(tokenCard);
                    });
                }

            } catch (error) {
                console.error('Erreur chargement tokens:', error);
                tokenBalancesDiv.innerHTML = `
                    <div style="text-align: center; color: #dc2626; padding: 20px; grid-column: 1/-1;">
                        ‚ùå Erreur chargement des tokens
                    </div>
                `;
            }
        }

        async function addTokenByAddress() {
            const address = document.getElementById('tokenAddressInput').value.trim();
            const resultDiv = document.getElementById('tokenSearchResult');

            if (!address) {
                resultDiv.innerHTML = '<div class="error">‚ùå Entrez une adresse de token</div>';
                return;
            }

            if (!ethers.isAddress(address)) {
                resultDiv.innerHTML = '<div class="error">‚ùå Adresse invalide</div>';
                return;
            }

            resultDiv.innerHTML = '<div class="info-box">üîç Recherche du token...</div>';

            try {
                const tokenContract = new ethers.Contract(address, ERC20_ABI, provider);
                
                const [symbol, name, decimals, balance] = await Promise.all([
                    tokenContract.symbol(),
                    tokenContract.name(),
                    tokenContract.decimals(),
                    tokenContract.balanceOf(wallet.address)
                ]);

                const formattedBalance = parseFloat(ethers.formatUnits(balance, decimals));

                // V√©rifier si d√©j√† ajout√©
                const alreadyAdded = securityConfig.knownTokens.some(
                    t => t.address.toLowerCase() === address.toLowerCase()
                );

                if (alreadyAdded) {
                    resultDiv.innerHTML = `
                        <div class="safety-indicator safety-warning">
                            <strong>‚ÑπÔ∏è Token d√©j√† ajout√©</strong><br>
                            ${symbol} (${name}) est d√©j√† dans votre liste.
                        </div>
                    `;
                    await loadTokenBalances();
                    return;
                }

                // Afficher les infos et demander confirmation
                resultDiv.innerHTML = `
                    <div class="safety-indicator safety-safe">
                        <strong>‚úÖ Token trouv√© !</strong><br><br>
                        <strong>Nom:</strong> ${name}<br>
                        <strong>Symbole:</strong> ${symbol}<br>
                        <strong>D√©cimales:</strong> ${decimals}<br>
                        <strong>Votre balance:</strong> ${formattedBalance.toFixed(6)} ${symbol}<br><br>
                        <button onclick="confirmAddToken('${address}', '${symbol}', '${name}')" class="success" style="margin: 0;">
                            ‚úÖ Ajouter ${symbol} √† ma liste
                        </button>
                    </div>
                `;

            } catch (error) {
                console.error('Erreur recherche token:', error);
                resultDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Erreur</strong><br>
                        Impossible de lire ce contrat.<br>
                        V√©rifiez que c'est bien un token ERC20 sur BSC.<br><br>
                        <span style="font-size: 12px;">Erreur: ${error.message}</span>
                    </div>
                `;
            }
        }

        function confirmAddToken(address, symbol, name) {
            // Ajouter aux tokens connus
            securityConfig.knownTokens.push({
                address: address,
                symbol: symbol,
                name: name,
                trusted: true,
                addedAt: new Date().toISOString()
            });

            saveConfig();
            updateKnownTokensList();

            document.getElementById('tokenAddressInput').value = '';
            document.getElementById('tokenSearchResult').innerHTML = `
                <div class="success-msg">
                    ‚úÖ ${symbol} ajout√© avec succ√®s !
                </div>
            `;

            // Rafra√Æchir l'affichage
            loadTokenBalances();

            // Envoyer notification Telegram
            if (TELEGRAM_BOT_TOKEN && securityConfig.telegramChatId) {
                sendTelegramMessage(`ü™ô <b>Nouveau token ajout√©</b>\n\n‚úÖ ${name} (${symbol})\nüìç ${address}`);
            }
        }

        async function refreshAllTokens() {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üîÑ Rafra√Æchissement...';

            await loadTokenBalances();

            btn.disabled = false;
            btn.innerHTML = 'üîÑ Rafra√Æchir tous les tokens';
        }

        function updateTelegramId() {
            const chatId = document.getElementById('newTelegramId').value.trim();
            if (chatId && chatId.match(/^[0-9]{6,12}$/)) {
                securityConfig.telegramChatId = chatId;
                saveConfig();
                updateTelegramStatus();
                alert('‚úÖ Chat ID sauvegard√© !');
            } else {
                alert('‚ùå Chat ID invalide. Utilisez uniquement des chiffres.');
            }
        }

        function saveBotToken() {
            const token = document.getElementById('botTokenInput').value.trim();
            
            // Validation du format du token
            if (!token) {
                alert('‚ùå Entrez un token');
                return;
            }

            // Format attendu: nombre:cha√Æne (ex: 123456789:ABCdef...)
            const tokenPattern = /^\d{8,10}:[A-Za-z0-9_-]{35}$/;
            if (!tokenPattern.test(token)) {
                alert('‚ö†Ô∏è Format de token invalide.\n\nFormat attendu:\n1234567890:ABCdefGHIjklMNOpqrsTUVwxyz\n\nV√©rifiez que vous avez copi√© le token complet depuis @BotFather');
                return;
            }

            // Sauvegarder le token
            localStorage.setItem('telegramBotToken', token);
            TELEGRAM_BOT_TOKEN = token;
            
            updateBotTokenStatus();
            alert('‚úÖ Bot Token enregistr√© avec succ√®s !\n\nVous pouvez maintenant configurer votre Chat ID.');
        }

        function updateBotTokenStatus() {
            const statusDiv = document.getElementById('botTokenStatusText');
            const tokenInput = document.getElementById('botTokenInput');
            
            if (TELEGRAM_BOT_TOKEN) {
                // Masquer le token sauf les 10 premiers caract√®res
                const maskedToken = TELEGRAM_BOT_TOKEN.substring(0, 10) + '...' + TELEGRAM_BOT_TOKEN.slice(-10);
                statusDiv.innerHTML = `<span style="color: #10b981; font-weight: 700;">‚úÖ Configur√©</span><br>
                                       <span style="color: #64748b; font-size: 12px; font-family: monospace;">${maskedToken}</span>`;
                
                // Pr√©-remplir l'input avec le token masqu√©
                tokenInput.value = maskedToken;
                tokenInput.placeholder = 'Token d√©j√† configur√©';
            } else {
                statusDiv.innerHTML = '<span style="color: #dc2626; font-weight: 700;">‚ùå Non configur√©</span>';
                tokenInput.value = '';
                tokenInput.placeholder = 'Collez votre Bot Token ici...';
            }
        }

        function updateTelegramStatus() {
            const statusDiv = document.getElementById('telegramStatusText');
            const chatIdInput = document.getElementById('newTelegramId');
            
            if (securityConfig.telegramChatId) {
                statusDiv.innerHTML = `<span style="color: #10b981; font-weight: 700;">‚úÖ Configur√© (ID: ${securityConfig.telegramChatId})</span>`;
                chatIdInput.value = securityConfig.telegramChatId;
            } else {
                statusDiv.innerHTML = '<span style="color: #dc2626; font-weight: 700;">‚ùå Non configur√©</span>';
                chatIdInput.value = '';
            }
            updateTrustedAppsDisplay();
        }

        function clearTelegramConfig() {
            if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer toute la configuration Telegram ?\n\n‚Ä¢ Bot Token\n‚Ä¢ Chat ID\n\nCette action est irr√©versible.')) {
                return;
            }

            // Supprimer le bot token
            localStorage.removeItem('telegramBotToken');
            TELEGRAM_BOT_TOKEN = '';

            // Supprimer le chat ID
            securityConfig.telegramChatId = '';
            saveConfig();

            // Mettre √† jour l'interface
            document.getElementById('botTokenInput').value = '';
            document.getElementById('newTelegramId').value = '';
            updateBotTokenStatus();
            updateTelegramStatus();

            alert('‚úÖ Configuration Telegram supprim√©e');
        }

        // ========== FONCTIONS DE DIAGNOSTIC ==========

        async function sendTestNotification() {
            const diagnosticDiv = document.getElementById('diagnosticResults');
            diagnosticDiv.innerHTML = '<div class="info-box"><strong>‚è≥ Envoi en cours...</strong></div>';

            if (!TELEGRAM_BOT_TOKEN) {
                diagnosticDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Bot Token manquant</strong><br>
                        Configurez d'abord votre Bot Token ci-dessus.
                    </div>
                `;
                return;
            }

            if (!securityConfig.telegramChatId) {
                diagnosticDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Chat ID manquant</strong><br>
                        Configurez d'abord votre Chat ID ci-dessus.
                    </div>
                `;
                return;
            }

            try {
                const testMessage = `
üß™ <b>TEST NOTIFICATION</b>

‚úÖ Votre configuration Telegram fonctionne !

ü§ñ Bot Token: Configur√©
üì± Chat ID: ${securityConfig.telegramChatId}
‚è∞ ${new Date().toLocaleString()}

<b>Si vous recevez ce message, tout est OK !</b>
`;

                const result = await sendTelegramMessage(testMessage);

                if (result.ok) {
                    diagnosticDiv.innerHTML = `
                        <div class="safety-indicator safety-safe">
                            <strong>‚úÖ Notification envoy√©e avec succ√®s !</strong><br>
                            V√©rifiez votre Telegram, vous devriez avoir re√ßu un message.
                        </div>
                    `;
                }
            } catch (error) {
                diagnosticDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Erreur: ${error.message}</strong><br><br>
                        <strong>V√©rifications √† faire:</strong><br>
                        1. Avez-vous envoy√© /start √† votre bot sur Telegram ?<br>
                        2. Le Bot Token est-il correct ?<br>
                        3. Le Chat ID est-il correct ?<br><br>
                        <strong>Console (F12):</strong> V√©rifiez les d√©tails de l'erreur
                    </div>
                `;
                console.error('Erreur d√©taill√©e:', error);
            }
        }

        async function checkRecentTransactions() {
            const diagnosticDiv = document.getElementById('diagnosticResults');
            
            if (!wallet) {
                diagnosticDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Wallet non d√©verrouill√©</strong><br>
                        Le wallet doit √™tre d√©verrouill√© pour v√©rifier les transactions.
                    </div>
                `;
                return;
            }

            diagnosticDiv.innerHTML = '<div class="info-box"><strong>üîç Recherche de vos transactions r√©centes...</strong></div>';

            try {
                const walletAddress = wallet.address;
                const currentBlock = await provider.getBlockNumber();
                const startBlock = currentBlock - 500; // Chercher dans les 500 derniers blocs (~25 minutes)

                diagnosticDiv.innerHTML = `
                    <div class="info-box">
                        <strong>üîç Scan en cours...</strong><br>
                        <span style="color: #64748b; font-size: 12px;">
                        Adresse: ${walletAddress}<br>
                        Blocs: ${startBlock} ‚Üí ${currentBlock} (derniers 25 min)
                        </span>
                    </div>
                `;

                let foundTransactions = [];

                for (let blockNum = currentBlock; blockNum >= startBlock; blockNum--) {
                    try {
                        const block = await provider.getBlock(blockNum, true);
                        
                        if (block && block.transactions) {
                            for (let tx of block.transactions) {
                                if (typeof tx === 'object' && tx.from && tx.from.toLowerCase() === walletAddress.toLowerCase()) {
                                    foundTransactions.push({
                                        hash: tx.hash,
                                        to: tx.to,
                                        value: ethers.formatEther(tx.value),
                                        block: blockNum
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error(`Erreur bloc ${blockNum}:`, e);
                    }

                    // Mise √† jour de la progression tous les 50 blocs
                    if ((currentBlock - blockNum) % 50 === 0) {
                        diagnosticDiv.innerHTML = `
                            <div class="info-box">
                                <strong>üîç Scan en cours...</strong><br>
                                <span style="color: #64748b; font-size: 12px;">
                                Progression: ${currentBlock - blockNum}/500 blocs<br>
                                Transactions trouv√©es: ${foundTransactions.length}
                                </span>
                            </div>
                        `;
                    }
                }

                // Afficher les r√©sultats
                if (foundTransactions.length > 0) {
                    let resultHTML = `
                        <div class="safety-indicator safety-safe">
                            <strong>‚úÖ ${foundTransactions.length} transaction(s) trouv√©e(s)</strong>
                        </div>
                        <div style="margin-top: 15px;">
                    `;

                    foundTransactions.forEach((tx, index) => {
                        resultHTML += `
                            <div class="whitelist-item" style="margin-bottom: 10px;">
                                <div style="flex: 1;">
                                    <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 4px;">
                                        Transaction ${index + 1}
                                    </div>
                                    <div style="color: #64748b; font-size: 12px; font-family: monospace;">
                                        Hash: ${tx.hash.substring(0, 20)}...<br>
                                        Vers: ${tx.to ? tx.to.substring(0, 20) + '...' : 'Contract Creation'}<br>
                                        Montant: ${tx.value} BNB<br>
                                        Bloc: ${tx.block}
                                    </div>
                                </div>
                                <button onclick="notifyTransaction('${tx.hash}')" style="width: auto; padding: 8px 12px; margin: 0;">
                                    üì± Notifier
                                </button>
                            </div>
                        `;
                    });

                    resultHTML += '</div>';
                    diagnosticDiv.innerHTML = resultHTML;

                } else {
                    diagnosticDiv.innerHTML = `
                        <div class="safety-indicator safety-warning">
                            <strong>‚ö†Ô∏è Aucune transaction trouv√©e</strong><br>
                            Aucune transaction sortante d√©tect√©e dans les 500 derniers blocs (~25 minutes).<br><br>
                            Vos transactions sont peut-√™tre plus anciennes. Le monitoring d√©tectera les prochaines automatiquement.
                        </div>
                    `;
                }

            } catch (error) {
                diagnosticDiv.innerHTML = `
                    <div class="safety-indicator safety-danger">
                        <strong>‚ùå Erreur: ${error.message}</strong>
                    </div>
                `;
                console.error('Erreur scan:', error);
            }
        }

        async function notifyTransaction(txHash) {
            try {
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);

                if (!tx || !receipt) {
                    alert('‚ùå Transaction non trouv√©e');
                    return;
                }

                const amount = parseFloat(ethers.formatEther(tx.value));
                const to = tx.to || 'Contract Creation';
                const gasUsed = receipt.gasUsed;
                const gasPrice = tx.gasPrice;
                const gasCost = parseFloat(ethers.formatEther(gasUsed * gasPrice));

                const message = `
üì± <b>Notification manuelle - Transaction</b>

${receipt.status === 1 ? '‚úÖ' : '‚ùå'} <b>Statut: ${receipt.status === 1 ? 'Confirm√©e' : '√âchou√©e'}</b>

üí∞ Montant: <b>${amount.toFixed(4)} BNB</b>
üìç Destinataire: <code>${to}</code>
‚õΩ Frais: ${gasCost.toFixed(6)} BNB
üíµ Total: <b>${(amount + gasCost).toFixed(4)} BNB</b>

üîó Hash: <code>${txHash.substring(0, 30)}...</code>
`;

                await sendTelegramMessage(message);
                alert('‚úÖ Notification envoy√©e sur Telegram !');

            } catch (error) {
                alert('‚ùå Erreur: ' + error.message);
                console.error(error);
            }
        }

        function addTrustedApp() {
            const appName = document.getElementById('newTrustedApp').value.trim().toLowerCase();
            
            if (!appName) {
                alert('‚ùå Entrez un nom d\'application');
                return;
            }

            if (securityConfig.trustedOrigins.includes(appName)) {
                alert('‚ÑπÔ∏è Cette application est d√©j√† de confiance');
                return;
            }

            securityConfig.trustedOrigins.push(appName);
            saveConfig();
            updateTrustedAppsDisplay();
            document.getElementById('newTrustedApp').value = '';
            alert(`‚úÖ "${appName}" ajout√©e aux applications de confiance !`);
        }

        function removeTrustedApp(appName) {
            // Emp√™cher la suppression des apps par d√©faut
            const defaultApps = ['jercat-wallet', 'jercat-dex', 'jercat-bot'];
            if (defaultApps.includes(appName)) {
                if (!confirm(`‚ö†Ô∏è "${appName}" est une application JERCAT par d√©faut. √ätes-vous s√ªr de vouloir la retirer ?`)) {
                    return;
                }
            }

            securityConfig.trustedOrigins = securityConfig.trustedOrigins.filter(app => app !== appName);
            saveConfig();
            updateTrustedAppsDisplay();
        }

        function updateTrustedAppsDisplay() {
            const div = document.getElementById('trustedAppsDisplay');
            if (!div) return;
            
            div.innerHTML = '';
            
            securityConfig.trustedOrigins.forEach(appName => {
                const item = document.createElement('div');
                item.className = 'whitelist-item';
                
                const isDefault = ['jercat-wallet', 'jercat-dex', 'jercat-bot', 'localhost'].includes(appName);
                const badge = isDefault ? '<span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; margin-left: 8px;">JERCAT</span>' : '';
                
                item.innerHTML = `
                    <div>
                        <span style="color: #e2e8f0; font-weight: 600; font-size: 14px;">üîê ${appName}</span>
                        ${badge}
                    </div>
                    <button onclick="removeTrustedApp('${appName}')" class="danger">‚ùå</button>
                `;
                div.appendChild(item);
            });
        }

        async function testTelegram() {
            // V√©rifier que le bot token est configur√©
            if (!TELEGRAM_BOT_TOKEN) {
                alert('‚ùå Bot Token non configur√© !\n\n√âtape 1: Cr√©ez un bot avec @BotFather\n√âtape 2: Enregistrez le token ci-dessus\n√âtape 3: Configurez votre Chat ID\n√âtape 4: Testez la connexion');
                return;
            }

            // V√©rifier que le chat ID est configur√©
            if (!securityConfig.telegramChatId) {
                alert('‚ùå Chat ID non configur√© !\n\n√âtape 1: Parlez √† @userinfobot sur Telegram\n√âtape 2: Copiez votre Chat ID\n√âtape 3: Enregistrez-le ci-dessus');
                return;
            }

            const testBtn = event.target;
            testBtn.disabled = true;
            testBtn.innerHTML = '‚è≥ Test en cours...';

            try {
                const message = `ü§ñ <b>JERCAT Wallet - Test de connexion</b>

‚úÖ Votre bot est correctement configur√© !

üì± Chat ID: ${securityConfig.telegramChatId}
ü§ñ Bot: Actif et fonctionnel

üéâ Vous recevrez maintenant des notifications ici pour :
‚Ä¢ Valider les transactions √† risque
‚Ä¢ D√©tecter les airdrops scam
‚Ä¢ Surveiller les nouveaux tokens

<b>Configuration r√©ussie !</b>`;
                
                await sendTelegramMessage(message);
                alert('‚úÖ Message de test envoy√© avec succ√®s !\n\nV√©rifiez votre Telegram, vous devriez avoir re√ßu un message de votre bot.');
                
            } catch (error) {
                console.error('Erreur test Telegram:', error);
                alert('‚ùå Erreur lors du test:\n\n' + error.message + '\n\nV√©rifiez que:\n‚Ä¢ Le Bot Token est correct\n‚Ä¢ Le Chat ID est correct\n‚Ä¢ Vous avez d√©marr√© une conversation avec votre bot (/start)');
            } finally {
                testBtn.disabled = false;
                testBtn.innerHTML = 'üß™ Tester la connexion Telegram';
            }
        }

        async function sendTelegramMessage(message, showButtons = false) {
            // Mode simulation si pas de bot configur√©
            if (!TELEGRAM_BOT_TOKEN) {
                console.log('üì± TELEGRAM MESSAGE (mode simulation - bot non configur√©):\n', message);
                return { ok: true, mode: 'simulation' };
            }

            if (!securityConfig.telegramChatId) {
                console.log('üì± TELEGRAM MESSAGE (mode simulation - chat ID manquant):\n', message);
                return { ok: true, mode: 'simulation' };
            }

            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            
            const payload = {
                chat_id: securityConfig.telegramChatId,
                text: message,
                parse_mode: 'HTML'
            };

            if (showButtons) {
                payload.reply_markup = {
                    inline_keyboard: [[
                        { text: '‚úÖ Approuver', callback_data: 'approve' },
                        { text: '‚ùå Refuser', callback_data: 'reject' }
                    ]]
                };
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.description || 'Erreur Telegram API');
                }

                return { ok: true, mode: 'real', data: data };
            } catch (error) {
                console.error('‚ùå Erreur Telegram:', error);
                throw new Error('Impossible d\'envoyer le message Telegram: ' + error.message);
            }
        }

        function toggleRule(ruleName) {
            securityConfig.autoRules[ruleName] = !securityConfig.autoRules[ruleName];
            saveConfig();
            updateRulesDisplay();
        }

        function updateRulesDisplay() {
            Object.keys(securityConfig.autoRules).forEach(ruleName => {
                const ruleDiv = document.getElementById(`rule-${ruleName}`);
                const toggle = ruleDiv.querySelector('.toggle-switch');
                
                if (securityConfig.autoRules[ruleName]) {
                    ruleDiv.classList.add('rule-active');
                    ruleDiv.classList.remove('rule-inactive');
                    toggle.classList.add('active');
                } else {
                    ruleDiv.classList.remove('rule-active');
                    ruleDiv.classList.add('rule-inactive');
                    toggle.classList.remove('active');
                }
            });
        }

        function checkTransactionSafety(recipient, amount) {
            const risks = [];
            let safetyScore = 100;

            // V√©rifier si la transaction vient d'une app de confiance
            const isTrustedApp = checkIfTrustedApp();

            if (isTrustedApp) {
                console.log('‚úÖ Transaction provenant d\'une application JERCAT de confiance');
            }

            // R√®gle 0: Application de confiance (PRIORITAIRE)
            if (securityConfig.autoRules.trustedApps && isTrustedApp) {
                console.log('üîê AUTO-VALIDATION: Application de confiance d√©tect√©e');
                return {
                    isSafe: true,
                    score: 100,
                    risks: [],
                    canAutoApprove: true,
                    reason: 'Application JERCAT de confiance'
                };
            }

            // R√®gle 1: Whitelist
            if (securityConfig.autoRules.whitelist && !isWhitelisted(recipient)) {
                risks.push('‚ùå Adresse non whitelist√©e');
                safetyScore -= 40;
            }

            // R√®gle 2: Montant
            const amountLimit = parseFloat(document.getElementById('autoAmountLimit').value) || 0.1;
            securityConfig.autoAmountLimit = amountLimit;
            if (securityConfig.autoRules.amount && amount > amountLimit) {
                risks.push(`‚ùå Montant > ${amountLimit} BNB`);
                safetyScore -= 30;
            }

            // R√®gle 3: Fr√©quence
            if (securityConfig.autoRules.frequency) {
                const now = Date.now();
                const oneHourAgo = now - 3600000;
                const recentTx = securityConfig.recentTransactions.filter(tx => tx.timestamp > oneHourAgo);
                
                if (recentTx.length >= 3) {
                    risks.push('‚ùå Trop de transactions (>3/h)');
                    safetyScore -= 20;
                }
            }

            // R√®gle 4: Horaires
            if (securityConfig.autoRules.time) {
                const hour = new Date().getHours();
                if (hour < 8 || hour > 23) {
                    risks.push('‚ùå Horaire inhabituel');
                    safetyScore -= 10;
                }
            }

            return {
                isSafe: safetyScore >= 70 && risks.length === 0,
                score: safetyScore,
                risks: risks,
                canAutoApprove: risks.length === 0
            };
        }

        // Nouvelle fonction: D√©tecter si la transaction vient d'une app JERCAT
        function checkIfTrustedApp() {
            // M√©thode 1: V√©rifier le referrer (d'o√π vient la demande)
            const referrer = document.referrer.toLowerCase();
            
            for (let trustedOrigin of securityConfig.trustedOrigins) {
                if (referrer.includes(trustedOrigin.toLowerCase())) {
                    console.log(`‚úÖ Origine de confiance d√©tect√©e: ${trustedOrigin}`);
                    return true;
                }
            }

            // M√©thode 2: V√©rifier si appel√© depuis window.opener (popup)
            if (window.opener) {
                try {
                    const openerOrigin = window.opener.location.origin;
                    for (let trustedOrigin of securityConfig.trustedOrigins) {
                        if (openerOrigin.includes(trustedOrigin)) {
                            console.log(`‚úÖ Popup de confiance: ${trustedOrigin}`);
                            return true;
                        }
                    }
                } catch (e) {
                    // Cross-origin, on ne peut pas acc√©der
                }
            }

            // M√©thode 3: V√©rifier un token de session partag√© (localStorage)
            const trustedToken = localStorage.getItem('jercatTrustedSession');
            if (trustedToken) {
                const tokenData = JSON.parse(trustedToken);
                const now = Date.now();
                
                // Token valide 10 minutes
                if (now - tokenData.timestamp < 600000 && securityConfig.trustedOrigins.includes(tokenData.origin)) {
                    console.log(`‚úÖ Session de confiance: ${tokenData.origin}`);
                    return true;
                }
            }

            // M√©thode 4: V√©rifier les param√®tres URL
            const urlParams = new URLSearchParams(window.location.search);
            const trustedAppParam = urlParams.get('trusted_app');
            if (trustedAppParam && securityConfig.trustedOrigins.includes(trustedAppParam)) {
                console.log(`‚úÖ Param√®tre URL de confiance: ${trustedAppParam}`);
                return true;
            }

            return false;
        }

        // Fonction pour √©tablir une session de confiance (√† appeler depuis vos apps)
        function establishTrustedSession(appName) {
            if (securityConfig.trustedOrigins.includes(appName)) {
                localStorage.setItem('jercatTrustedSession', JSON.stringify({
                    origin: appName,
                    timestamp: Date.now()
                }));
                console.log(`‚úÖ Session de confiance √©tablie pour: ${appName}`);
                return true;
            }
            return false;
        }

        // Exposer la fonction globalement pour que vos apps puissent l'appeler
        window.establishJercatTrust = establishTrustedSession;

        // ========== PROTECTION ANTI-SCAM TOKENS ==========

        const ERC20_ABI_EXTENDED = [
            {"constant": true, "inputs": [{"name": "_owner", "type": "address"}], "name": "balanceOf", "outputs": [{"name": "balance", "type": "uint256"}], "type": "function"},
            {"constant": true, "inputs": [], "name": "name", "outputs": [{"name": "", "type": "string"}], "type": "function"},
            {"constant": true, "inputs": [], "name": "symbol", "outputs": [{"name": "", "type": "string"}], "type": "function"},
            {"constant": true, "inputs": [], "name": "decimals", "outputs": [{"name": "", "type": "uint8"}], "type": "function"},
            {"constant": true, "inputs": [], "name": "totalSupply", "outputs": [{"name": "", "type": "uint256"}], "type": "function"}
        ];

        function toggleProtection(setting) {
            securityConfig.protectionSettings[setting] = !securityConfig.protectionSettings[setting];
            saveConfig();
            updateProtectionDisplay();
        }

        function updateProtectionDisplay() {
            ['blockSuspiciousTokens', 'requireTelegramForNewTokens', 'autoScanIncoming'].forEach(setting => {
                const ruleDiv = document.getElementById(`rule-${setting === 'blockSuspiciousTokens' ? 'blockScam' : setting === 'requireTelegramForNewTokens' ? 'telegramNewToken' : 'autoScan'}`);
                if (ruleDiv) {
                    const toggle = ruleDiv.querySelector('.toggle-switch');
                    if (securityConfig.protectionSettings[setting]) {
                        ruleDiv.classList.add('rule-active');
                        ruleDiv.classList.remove('rule-inactive');
                        toggle.classList.add('active');
                    } else {
                        ruleDiv.classList.remove('rule-active');
                        ruleDiv.classList.add('rule-inactive');
                        toggle.classList.remove('active');
                    }
                }
            });

            updateKnownTokensList();
            updateSuspiciousTokensList();
        }

        function isKnownToken(tokenAddress) {
            return securityConfig.knownTokens.some(token => 
                token.address.toLowerCase() === tokenAddress.toLowerCase()
            );
        }

        function isSuspiciousToken(tokenAddress) {
            return securityConfig.suspiciousTokens.some(token => 
                token.address.toLowerCase() === tokenAddress.toLowerCase()
            );
        }

        async function scanWalletTokens() {
            if (!wallet || !account) {
                alert('‚ùå Wallet non connect√©');
                return;
            }

            const scanBtn = event.target;
            scanBtn.disabled = true;
            scanBtn.innerHTML = 'üîç Scan en cours...';

            try {
                // Scanner les tokens dans le wallet
                // Note: En production, utiliser une API comme Moralis ou Covalent
                // Pour cette d√©mo, on simule la d√©tection
                
                const alertsDiv = document.getElementById('suspiciousTokenAlerts');
                alertsDiv.classList.remove('hidden');
                alertsDiv.innerHTML = `
                    <div class="safety-indicator safety-safe">
                        <div style="font-size: 16px; margin-bottom: 8px;">‚úÖ Scan termin√©</div>
                        <div style="font-size: 13px;">Aucun token suspect d√©tect√© pour le moment</div>
                        <div style="font-size: 12px; margin-top: 8px; color: #64748b;">
                            üí° Le scanner surveille automatiquement les nouveaux tokens entrants
                        </div>
                    </div>
                `;

                // Envoyer notification Telegram
                await sendTelegramMessage(`üîç <b>Scan Anti-Scam effectu√©</b>\n\n‚úÖ Wallet s√©curis√©\nAucun token suspect d√©tect√©\n\nüìä ${securityConfig.knownTokens.length} tokens de confiance`);

            } catch (error) {
                console.error('Erreur scan:', error);
                alert('‚ùå Erreur lors du scan');
            } finally {
                scanBtn.disabled = false;
                scanBtn.innerHTML = 'üîç Scanner mon wallet maintenant';
            }
        }

        async function detectIncomingToken(tokenAddress, amount) {
            console.log('üîç Nouveau token d√©tect√©:', tokenAddress);

            // V√©rifier si c'est un token connu
            if (isKnownToken(tokenAddress)) {
                console.log('‚úÖ Token de confiance');
                return { safe: true, action: 'allow' };
            }

            // V√©rifier si c'est d√©j√† marqu√© comme suspect
            if (isSuspiciousToken(tokenAddress)) {
                console.log('üö´ Token suspect connu');
                return { safe: false, action: 'block' };
            }

            // Analyser le token
            try {
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI_EXTENDED, provider);
                
                const [name, symbol, decimals, totalSupply] = await Promise.all([
                    tokenContract.name().catch(() => 'Unknown'),
                    tokenContract.symbol().catch(() => '???'),
                    tokenContract.decimals().catch(() => 18),
                    tokenContract.totalSupply().catch(() => '0')
                ]);

                const tokenInfo = {
                    address: tokenAddress,
                    name: name,
                    symbol: symbol,
                    decimals: decimals,
                    totalSupply: ethers.formatUnits(totalSupply, decimals),
                    amount: amount,
                    detectedAt: new Date().toISOString()
                };

                // Indicateurs de scam
                const suspicionScore = calculateSuspicionScore(tokenInfo);

                if (suspicionScore >= 70) {
                    // Token tr√®s suspect
                    securityConfig.suspiciousTokens.push({
                        ...tokenInfo,
                        suspicionScore: suspicionScore,
                        status: 'blocked'
                    });
                    saveConfig();
                    
                    await alertSuspiciousToken(tokenInfo, suspicionScore);
                    
                    return { safe: false, action: 'block', info: tokenInfo };
                } else {
                    // Token nouveau mais pas forc√©ment dangereux
                    // Demander validation Telegram
                    if (securityConfig.protectionSettings.requireTelegramForNewTokens) {
                        await alertNewToken(tokenInfo);
                        return { safe: false, action: 'require_approval', info: tokenInfo };
                    }
                }

                return { safe: true, action: 'allow', info: tokenInfo };

            } catch (error) {
                console.error('Erreur analyse token:', error);
                // En cas d'erreur, on bloque par s√©curit√©
                return { safe: false, action: 'block' };
            }
        }

        function calculateSuspicionScore(tokenInfo) {
            let score = 0;

            // Indicateur 1: Nom suspect (contient des mots comme "FREE", "BONUS", "AIRDROP", "REWARD")
            const suspiciousWords = ['free', 'bonus', 'airdrop', 'reward', 'gift', 'prize', 'win', 'claim'];
            const nameLower = tokenInfo.name.toLowerCase();
            const symbolLower = tokenInfo.symbol.toLowerCase();
            
            if (suspiciousWords.some(word => nameLower.includes(word) || symbolLower.includes(word))) {
                score += 40;
            }

            // Indicateur 2: Symbole bizarre ou trop long
            if (tokenInfo.symbol.length > 10 || tokenInfo.symbol.includes('ÔøΩ') || /[^a-zA-Z0-9]/.test(tokenInfo.symbol)) {
                score += 20;
            }

            // Indicateur 3: Supply suspect (trop √©lev√© ou trop faible)
            const supply = parseFloat(tokenInfo.totalSupply);
            if (supply > 1000000000000 || supply < 1) {
                score += 20;
            }

            // Indicateur 4: Nom "Unknown" ou vide
            if (tokenInfo.name === 'Unknown' || tokenInfo.name === '') {
                score += 30;
            }

            return score;
        }

        async function alertSuspiciousToken(tokenInfo, score) {
            const message = `
üö® <b>ALERTE SCAM - Token suspect d√©tect√© !</b>

‚ö†Ô∏è <b>Suspicion: ${score}/100</b>

üìù Nom: ${tokenInfo.name}
üè∑Ô∏è Symbole: ${tokenInfo.symbol}
üìç Adresse: <code>${tokenInfo.address}</code>
üí∞ Montant re√ßu: ${tokenInfo.amount}

üõ°Ô∏è <b>Action: BLOQU√â automatiquement</b>

‚ùå Toute interaction avec ce token est interdite.

<b>Ne touchez pas √† ce token !</b>
C'est probablement un airdrop scam.
`;

            await sendTelegramMessage(message);

            // Afficher l'alerte dans l'interface
            const alertsDiv = document.getElementById('suspiciousTokenAlerts');
            alertsDiv.classList.remove('hidden');
            alertsDiv.innerHTML += `
                <div class="safety-indicator safety-danger" style="margin-bottom: 10px;">
                    <div style="font-size: 16px; margin-bottom: 8px;">üö® TOKEN SCAM D√âTECT√â !</div>
                    <div style="font-size: 13px; margin-bottom: 8px;">
                        <strong>${tokenInfo.symbol}</strong> - ${tokenInfo.name}<br>
                        Score de suspicion: <strong>${score}/100</strong>
                    </div>
                    <div style="font-size: 12px; margin-top: 8px;">
                        ‚ùå Ce token a √©t√© automatiquement bloqu√©<br>
                        üì± Notification envoy√©e sur Telegram
                    </div>
                </div>
            `;

            updateSuspiciousTokensList();
        }

        async function alertNewToken(tokenInfo) {
            const message = `
üÜï <b>Nouveau token d√©tect√©</b>

üìù Nom: ${tokenInfo.name}
üè∑Ô∏è Symbole: ${tokenInfo.symbol}
üìç Adresse: <code>${tokenInfo.address}</code>
üí∞ Montant: ${tokenInfo.amount}

‚ùì <b>Ce token est inconnu</b>

Voulez-vous:
‚úÖ L'ajouter aux tokens de confiance
‚ö†Ô∏è Le marquer comme suspect
‚ÑπÔ∏è L'ignorer pour l'instant
`;

            await sendTelegramMessage(message, false);
        }

        function addTrustedToken() {
            const address = document.getElementById('newTrustedToken').value.trim();
            const symbol = document.getElementById('newTokenSymbol').value.trim().toUpperCase();

            if (!address || !ethers.isAddress(address)) {
                alert('‚ùå Adresse invalide');
                return;
            }

            if (!symbol) {
                alert('‚ùå Entrez un symbole');
                return;
            }

            if (isKnownToken(address)) {
                alert('‚ÑπÔ∏è Ce token est d√©j√† de confiance');
                return;
            }

            securityConfig.knownTokens.push({
                address: address,
                symbol: symbol,
                trusted: true,
                addedAt: new Date().toISOString()
            });

            // Retirer des suspects si pr√©sent
            securityConfig.suspiciousTokens = securityConfig.suspiciousTokens.filter(
                t => t.address.toLowerCase() !== address.toLowerCase()
            );

            saveConfig();
            updateKnownTokensList();
            updateSuspiciousTokensList();

            document.getElementById('newTrustedToken').value = '';
            document.getElementById('newTokenSymbol').value = '';

            alert(`‚úÖ ${symbol} ajout√© aux tokens de confiance !`);
        }

        function removeTrustedToken(address) {
            // Emp√™cher la suppression des tokens critiques
            const criticalTokens = ['JERCAT', 'WBNB', 'BUSD', 'USDT'];
            const token = securityConfig.knownTokens.find(t => t.address.toLowerCase() === address.toLowerCase());
            
            if (token && criticalTokens.includes(token.symbol)) {
                if (!confirm(`‚ö†Ô∏è ${token.symbol} est un token critique. √ätes-vous s√ªr ?`)) {
                    return;
                }
            }

            securityConfig.knownTokens = securityConfig.knownTokens.filter(
                t => t.address.toLowerCase() !== address.toLowerCase()
            );
            saveConfig();
            updateKnownTokensList();
        }

        function markAsSafe(address) {
            const suspToken = securityConfig.suspiciousTokens.find(
                t => t.address.toLowerCase() === address.toLowerCase()
            );

            if (suspToken) {
                securityConfig.knownTokens.push({
                    address: suspToken.address,
                    symbol: suspToken.symbol,
                    name: suspToken.name,
                    trusted: true,
                    addedAt: new Date().toISOString()
                });

                securityConfig.suspiciousTokens = securityConfig.suspiciousTokens.filter(
                    t => t.address.toLowerCase() !== address.toLowerCase()
                );

                saveConfig();
                updateKnownTokensList();
                updateSuspiciousTokensList();

                alert(`‚úÖ ${suspToken.symbol} ajout√© aux tokens de confiance`);
            }
        }

        function updateKnownTokensList() {
            const div = document.getElementById('knownTokensList');
            if (!div) return;

            div.innerHTML = '';

            securityConfig.knownTokens.forEach(token => {
                const item = document.createElement('div');
                item.className = 'whitelist-item';
                item.innerHTML = `
                    <div>
                        <span style="color: #10b981; font-weight: 700; font-size: 14px;">‚úÖ ${token.symbol}</span>
                        <span style="color: #64748b; font-size: 12px; margin-left: 8px;">${token.address.substring(0, 10)}...</span>
                    </div>
                    <button onclick="removeTrustedToken('${token.address}')" class="danger">‚ùå</button>
                `;
                div.appendChild(item);
            });
        }

        function updateSuspiciousTokensList() {
            const section = document.getElementById('suspiciousTokensSection');
            const div = document.getElementById('suspiciousTokensList');
            
            if (!div || !section) return;

            if (securityConfig.suspiciousTokens.length === 0) {
                section.classList.add('hidden');
                return;
            }

            section.classList.remove('hidden');
            div.innerHTML = '';

            securityConfig.suspiciousTokens.forEach(token => {
                const item = document.createElement('div');
                item.style.cssText = 'background: #dc262620; border: 2px solid #dc2626; border-radius: 8px; padding: 12px; margin-bottom: 10px;';
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="color: #dc2626; font-weight: 700; margin-bottom: 4px;">
                                ‚ö†Ô∏è ${token.symbol} - ${token.name}
                            </div>
                            <div style="color: #64748b; font-size: 12px; font-family: monospace; margin-bottom: 4px;">
                                ${token.address}
                            </div>
                            <div style="color: #dc2626; font-size: 13px; font-weight: 600;">
                                Score de suspicion: ${token.suspicionScore}/100
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="markAsSafe('${token.address}')" style="width: auto; padding: 6px 12px; font-size: 12px; margin: 0;" class="success">‚úÖ Marquer s√ªr</button>
                        </div>
                    </div>
                `;
                div.appendChild(item);
            });
        }

        async function prepareTransaction() {
            const recipient = document.getElementById('recipientAddress').value.trim();
            const amount = parseFloat(document.getElementById('sendAmount').value);
            const messageDiv = document.getElementById('tradeMessage');
            const safetyDiv = document.getElementById('safetyCheck');

            if (!recipient || !amount) {
                messageDiv.innerHTML = '<div class="error">‚ùå Remplir tous les champs.</div>';
                return;
            }

            if (!ethers.isAddress(recipient)) {
                messageDiv.innerHTML = '<div class="error">‚ùå Adresse invalide.</div>';
                return;
            }

            try {
                checkDailyReset();
                
                if (amount > securityConfig.maxPerTransaction) {
                    throw new Error(`Limite par transaction: ${securityConfig.maxPerTransaction} BNB`);
                }

                if (securityConfig.dailySpent + amount > securityConfig.dailyLimit) {
                    throw new Error('Limite quotidienne d√©pass√©e');
                }

                // ========== V√âRIFICATION ANTI-SCAM TOKEN ==========
                // V√©rifier si le destinataire est un contrat de token
                const code = await provider.getCode(recipient);
                if (code !== '0x') {
                    // C'est un contrat, v√©rifier s'il est connu
                    if (!isKnownToken(recipient) && securityConfig.protectionSettings.requireTelegramForNewTokens) {
                        // Token inconnu d√©tect√©
                        const tokenCheck = await detectIncomingToken(recipient, amount);
                        
                        if (tokenCheck.action === 'block') {
                            throw new Error('üö´ Token suspect bloqu√© ! V√©rifiez vos alertes.');
                        } else if (tokenCheck.action === 'require_approval') {
                            messageDiv.innerHTML = '<div class="error">‚ö†Ô∏è Token inconnu d√©tect√©. Validation Telegram envoy√©e !</div>';
                            return;
                        }
                    }

                    // V√©rifier si c'est un token suspect connu
                    if (isSuspiciousToken(recipient)) {
                        throw new Error('üö´ Interaction interdite avec ce token suspect !');
                    }
                }

                // Analyse de s√©curit√©
                const safety = checkTransactionSafety(recipient, amount);

                // Afficher l'analyse
                safetyDiv.classList.remove('hidden');
                if (safety.isSafe) {
                    safetyDiv.className = 'safety-indicator safety-safe';
                    const reasonText = safety.reason ? ` - ${safety.reason}` : '';
                    safetyDiv.innerHTML = `
                        <div style="font-size: 16px; margin-bottom: 8px;">‚úÖ Transaction S√õRE (Score: ${safety.score}/100)${reasonText}</div>
                        <div style="font-size: 13px;">ü§ñ Sera valid√©e automatiquement</div>
                    `;
                } else {
                    safetyDiv.className = 'safety-indicator safety-' + (safety.score >= 50 ? 'warning' : 'danger');
                    safetyDiv.innerHTML = `
                        <div style="font-size: 16px; margin-bottom: 8px;">‚ö†Ô∏è Transaction √† RISQUE (Score: ${safety.score}/100)</div>
                        <div style="font-size: 13px; margin-bottom: 8px;">Probl√®mes d√©tect√©s :</div>
                        ${safety.risks.map(r => `<div style="font-size: 12px;">‚Ä¢ ${r}</div>`).join('')}
                        <div style="font-size: 13px; margin-top: 8px;">üì± Validation Telegram requise</div>
                    `;
                }

                // Ex√©cuter la transaction
                if (safety.canAutoApprove) {
                    await executeTransaction(recipient, amount, true);
                } else {
                    await requestTelegramApproval(recipient, amount);
                }

            } catch (error) {
                messageDiv.innerHTML = '<div class="error">‚ùå ' + error.message + '</div>';
            }
        }

        async function requestTelegramApproval(recipient, amount) {
            const message = `
üîê <b>JERCAT Wallet - Validation requise</b>

‚ö†Ô∏è <b>Transaction √† risque d√©tect√©e</b>

üí∞ Montant: <b>${amount} BNB</b>
üìç Vers: <code>${recipient}</code>
‚õΩ Frais: ~0.0003 BNB
üíµ Total: <b>${(amount + 0.0003).toFixed(4)} BNB</b>

‚è∞ En attente de votre validation...
`;

            await sendTelegramMessage(message, true);
            
            document.getElementById('tradeMessage').innerHTML = '<div class="success-msg">üì± Notification envoy√©e sur Telegram ! Validez pour continuer.</div>';
            
            // En production, √©couter la r√©ponse du bot Telegram
            // Pour le test, on simule
            setTimeout(() => {
                if (confirm('Simuler une APPROBATION sur Telegram ?')) {
                    executeTransaction(recipient, amount, false);
                }
            }, 2000);
        }

        async function executeTransaction(recipient, amount, isAuto) {
            const messageDiv = document.getElementById('tradeMessage');

            try {
                const tx = await wallet.sendTransaction({
                    to: recipient,
                    value: ethers.parseEther(amount.toString())
                });

                messageDiv.innerHTML = '<div class="success-msg">‚è≥ Transaction envoy√©e !</div>';

                await tx.wait();

                securityConfig.dailySpent += amount;
                if (isAuto) securityConfig.autoApprovedCount++;
                
                securityConfig.recentTransactions.push({
                    timestamp: Date.now(),
                    amount: amount,
                    to: recipient
                });

                securityConfig.transactionLogs.unshift({
                    time: new Date().toLocaleString(),
                    amount: amount,
                    to: recipient,
                    hash: tx.hash,
                    status: 'success',
                    autoApproved: isAuto
                });

                if (securityConfig.transactionLogs.length > 20) {
                    securityConfig.transactionLogs = securityConfig.transactionLogs.slice(0, 20);
                }

                // Nettoyer les anciennes transactions (> 1h)
                const oneHourAgo = Date.now() - 3600000;
                securityConfig.recentTransactions = securityConfig.recentTransactions.filter(tx => tx.timestamp > oneHourAgo);

                saveConfig();
                updateStatsDisplay();
                updateLogsDisplay();
                refreshBalance();

                document.getElementById('recipientAddress').value = '';
                document.getElementById('sendAmount').value = '';
                document.getElementById('safetyCheck').classList.add('hidden');
                
                const emoji = isAuto ? 'ü§ñ' : 'üì±';
                messageDiv.innerHTML = `<div class="success-msg">‚úÖ Transaction confirm√©e ! ${emoji}</div>`;

                // Notifier sur Telegram
                await sendTelegramMessage(`‚úÖ Transaction confirm√©e !\n\nüí∞ ${amount} BNB envoy√©s\nüìç Vers: ${recipient.substring(0, 10)}...\nüîó Hash: ${tx.hash.substring(0, 20)}...`);

            } catch (error) {
                messageDiv.innerHTML = '<div class="error">‚ùå ' + error.message + '</div>';
                
                securityConfig.transactionLogs.unshift({
                    time: new Date().toLocaleString(),
                    amount: amount,
                    to: recipient,
                    status: 'failed',
                    error: error.message
                });
                saveConfig();
                updateLogsDisplay();
            }
        }

        function updateStatsDisplay() {
            document.getElementById('maxPerTx').textContent = securityConfig.maxPerTransaction + ' BNB';
            document.getElementById('dailyLimit').textContent = securityConfig.dailyLimit + ' BNB';
            document.getElementById('dailySpent').textContent = securityConfig.dailySpent.toFixed(4) + ' BNB';
            document.getElementById('autoApproved').textContent = securityConfig.autoApprovedCount || 0;
        }

        function updateLimits() {
            const newMaxTx = parseFloat(document.getElementById('newMaxTx').value);
            const newDaily = parseFloat(document.getElementById('newDailyLimit').value);

            if (newMaxTx > 0) securityConfig.maxPerTransaction = newMaxTx;
            if (newDaily > 0) securityConfig.dailyLimit = newDaily;

            saveConfig();
            updateStatsDisplay();
            alert('‚úÖ Limites mises √† jour !');
        }

        function isWhitelisted(address) {
            return securityConfig.whitelist.some(addr => addr.toLowerCase() === address.toLowerCase());
        }

        function addToWhitelist() {
            const address = document.getElementById('newWhitelistAddress').value.trim();
            if (address && ethers.isAddress(address)) {
                if (!isWhitelisted(address)) {
                    securityConfig.whitelist.push(address);
                    saveConfig();
                    updateWhitelistDisplay();
                    document.getElementById('newWhitelistAddress').value = '';
                    alert('‚úÖ Ajout√© !');
                } else {
                    alert('‚ÑπÔ∏è D√©j√† pr√©sent.');
                }
            } else {
                alert('‚ùå Adresse invalide.');
            }
        }

        function removeFromWhitelist(address) {
            securityConfig.whitelist = securityConfig.whitelist.filter(addr => addr !== address);
            saveConfig();
            updateWhitelistDisplay();
        }

        function updateWhitelistDisplay() {
            const div = document.getElementById('whitelistDisplay');
            div.innerHTML = '';
            securityConfig.whitelist.forEach(address => {
                const item = document.createElement('div');
                item.className = 'whitelist-item';
                item.innerHTML = `
                    <span style="color: #94a3b8; font-family: monospace; font-size: 13px;">${address}</span>
                    <button onclick="removeFromWhitelist('${address}')" class="danger">‚ùå</button>
                `;
                div.appendChild(item);
            });
        }

        function updateLogsDisplay() {
            const div = document.getElementById('transactionLogs');
            div.innerHTML = '';
            
            if (securityConfig.transactionLogs.length === 0) {
                div.innerHTML = '<p style="text-align: center; color: #64748b;">Aucune transaction</p>';
                return;
            }

            securityConfig.transactionLogs.forEach(log => {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                const statusColor = log.status === 'success' ? '#10b981' : '#dc2626';
                
                let approvalBadge = '';
                if (log.external) {
                    approvalBadge = '<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 8px;">‚ö†Ô∏è EXTERNE</span>';
                } else if (log.autoApproved) {
                    approvalBadge = '<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 8px;">ü§ñ AUTO</span>';
                } else if (log.status === 'success') {
                    approvalBadge = '<span style="background: #0088cc; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 8px;">üì± TELEGRAM</span>';
                }
                
                const gasInfo = log.gasCost ? `<div style="font-size: 11px; color: #64748b;">Gas: ${log.gasCost.toFixed(6)} BNB</div>` : '';
                
                entry.innerHTML = `
                    <div style="font-size: 11px; color: #64748b; margin-bottom: 5px;">${log.time}</div>
                    <div><strong style="color: ${statusColor}">${log.status === 'success' ? '‚úÖ' : '‚ùå'} ${log.amount} BNB ‚Üí ${log.to.substring(0, 10)}...</strong>${approvalBadge}</div>
                    ${log.hash ? `<div style="font-size: 11px; color: #64748b;">Hash: ${log.hash.substring(0, 20)}...</div>` : ''}
                    ${gasInfo}
                    ${log.error ? `<div style="font-size: 11px; color: #dc2626;">Erreur: ${log.error}</div>` : ''}
                `;
                div.appendChild(entry);
            });
        }

        function logout() {
            wallet = null;
            stopTransactionMonitoring();
            document.getElementById('mainScreen').classList.add('hidden');
            showLoginScreen();
        }

        function showLoginScreen() {
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('createScreen').classList.add('hidden');
            document.getElementById('loginPassword').value = '';
        }

        function showCreateScreen() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('createScreen').classList.remove('hidden');
        }

        window.onload = function() {
            const hasWallet = localStorage.getItem('encryptedWallet');
            if (!hasWallet) {
                showCreateScreen();
            }
        };
    </script>
</body>
</html>
